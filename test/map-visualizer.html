<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Abyssal Dungeon - Map Generator v5</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }
        h1 { text-align: center; color: #ffd700; margin-bottom: 10px; }
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; }
        .legend {
            display: flex; justify-content: center; gap: 20px;
            margin-bottom: 20px; font-size: 14px;
        }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-color { width: 20px; height: 20px; border: 1px solid #666; }
        .controls { text-align: center; margin-bottom: 20px; }
        button {
            background: #4a4a6a; color: #fff; border: 2px solid #ffd700;
            padding: 10px 20px; font-size: 14px; cursor: pointer;
            margin: 5px; border-radius: 5px;
        }
        button:hover { background: #6a6a8a; }
        .grid {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 15px; max-width: 1400px; margin: 0 auto;
        }
        .map-container {
            background: #2a2a4a; border: 2px solid #4a4a6a;
            border-radius: 8px; padding: 10px;
        }
        .map-header {
            display: flex; justify-content: space-between;
            margin-bottom: 8px; font-size: 11px;
        }
        .map-header .shape { color: #ffd700; font-weight: bold; }
        .map-header .stats { color: #888; }
        canvas {
            display: block; width: 100%;
            image-rendering: pixelated; border: 1px solid #333;
        }
    </style>
</head>
<body>
    <h1>Abyssal Dungeon - Map Generator v5</h1>
    <p class="subtitle">Â¢ÉÁïåÂ£Å„ÅßÈñâ„Åò„Çã / „Éâ„Ç¢„ÅØ‰∏°ÂÅ¥Â£Å„ÅßÊåü„ÇÄ</p>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #1a1a2e;"></div>
            <span>Void (È†òÂüüÂ§ñ)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #5a5a7a;"></div>
            <span>Wall (Â£Å)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #2a2a3a;"></div>
            <span>Floor (Â∫ä)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8B4513;"></div>
            <span>Door („Éâ„Ç¢)</span>
        </div>
    </div>

    <div class="controls">
        <button onclick="generateAll()">üîÑ Regenerate All</button>
        <button onclick="generateByShape('blob')">Blob</button>
        <button onclick="generateByShape('L')">L-Shape</button>
        <button onclick="generateByShape('cross')">Cross</button>
        <button onclick="generateByShape('donut')">Donut</button>
        <button onclick="generateByShape('caves')">Caves</button>
    </div>
    <div class="grid" id="grid"></div>

    <script>
    // Map cell values: -1=void, 0=floor, 1=wall, 2=door

    class DungeonGenerator {
        constructor(maxSize = 36) {
            this.maxSize = maxSize;
        }

        generate(depth = 1, forceShape = null) {
            const maxAttempts = 20;
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const result = this.tryGenerate(depth, forceShape);
                if (result) return result;
            }
            // Fallback: return last attempt anyway
            return this.tryGenerate(depth, forceShape, true);
        }

        tryGenerate(depth, forceShape, force = false) {
            const baseSize = Math.min(22 + depth * 2, this.maxSize);
            const shapes = ['blob', 'L', 'cross', 'donut', 'caves'];
            const shapeType = forceShape || shapes[Math.floor(Math.random() * shapes.length)];

            // Initialize with void
            const map = Array.from({ length: this.maxSize }, () =>
                Array(this.maxSize).fill(-1)
            );

            // Generate shape mask
            const mask = this.generateShape(shapeType, baseSize);
            const offset = Math.floor((this.maxSize - baseSize) / 2);

            // Fill mask area with FLOOR
            for (let z = 0; z < baseSize; z++) {
                for (let x = 0; x < baseSize; x++) {
                    if (mask[z][x]) {
                        map[z + offset][x + offset] = 0; // floor
                    }
                }
            }

            // Add boundary walls between floor and void
            this.addBoundaryWalls(map);

            // Generate rooms (build walls on floor)
            const rooms = this.generateRooms(map, offset, baseSize, mask, depth);

            // Connect rooms (various patterns)
            this.connectRooms(map, rooms);

            // Add some pillars/obstacles in open spaces
            this.addObstacles(map, rooms);

            // Final pass: ensure all floor/door cells are enclosed
            this.ensureEnclosure(map);

            // Validate and fix doors
            this.validateDoors(map);

            // Check connectivity - reject if isolated areas exist
            if (!force && !this.isFullyConnected(map)) {
                return null; // Retry
            }

            return {
                map, rooms,
                shape: shapeType,
                size: baseSize,
                walkable: this.countCells(map, [0, 2]),
                doors: this.countCells(map, [2])
            };
        }

        generateShape(type, size) {
            const mask = Array.from({ length: size }, () => Array(size).fill(false));
            const cx = size / 2, cz = size / 2;
            const r = size / 2 - 2;

            switch (type) {
                case 'blob': {
                    const seed = Math.random() * 100;
                    for (let z = 0; z < size; z++) {
                        for (let x = 0; x < size; x++) {
                            const dx = x - cx, dz = z - cz;
                            const dist = Math.sqrt(dx*dx + dz*dz);
                            const angle = Math.atan2(dz, dx);
                            const wavy = r * (0.7 + 0.3 * Math.sin(angle*3 + seed) * Math.cos(angle*2 + seed*0.7));
                            if (dist < wavy) mask[z][x] = true;
                        }
                    }
                    break;
                }
                case 'L': {
                    const arm = Math.floor(size * 0.5);
                    const rot = Math.floor(Math.random() * 4);
                    for (let z = 0; z < size; z++) {
                        for (let x = 0; x < size; x++) {
                            let inShape = false;
                            if (rot === 0) inShape = x < arm || z >= size - arm;
                            else if (rot === 1) inShape = x >= size - arm || z >= size - arm;
                            else if (rot === 2) inShape = x >= size - arm || z < arm;
                            else inShape = x < arm || z < arm;
                            if (inShape) mask[z][x] = true;
                        }
                    }
                    break;
                }
                case 'cross': {
                    const arm = Math.floor(size * 0.35);
                    for (let z = 0; z < size; z++) {
                        for (let x = 0; x < size; x++) {
                            const inV = x >= cx - arm/2 && x < cx + arm/2;
                            const inH = z >= cz - arm/2 && z < cz + arm/2;
                            if (inV || inH) mask[z][x] = true;
                        }
                    }
                    break;
                }
                case 'donut': {
                    const outer = r + 2, inner = r * 0.3;
                    for (let z = 0; z < size; z++) {
                        for (let x = 0; x < size; x++) {
                            const d = Math.sqrt((x-cx)**2 + (z-cz)**2);
                            if (d < outer && d > inner) mask[z][x] = true;
                        }
                    }
                    break;
                }
                case 'caves': {
                    for (let z = 1; z < size-1; z++) {
                        for (let x = 1; x < size-1; x++) {
                            const d = Math.sqrt((x-cx)**2 + (z-cz)**2);
                            if (d < r + 2) mask[z][x] = Math.random() < 0.55;
                        }
                    }
                    for (let i = 0; i < 5; i++) {
                        const next = mask.map(row => [...row]);
                        for (let z = 1; z < size-1; z++) {
                            for (let x = 1; x < size-1; x++) {
                                let n = 0;
                                for (let dz = -1; dz <= 1; dz++)
                                    for (let dx = -1; dx <= 1; dx++)
                                        if (mask[z+dz]?.[x+dx]) n++;
                                next[z][x] = n >= 5;
                            }
                        }
                        for (let z = 0; z < size; z++)
                            for (let x = 0; x < size; x++)
                                mask[z][x] = next[z][x];
                    }
                    break;
                }
            }
            return mask;
        }

        // Add walls at the boundary between floor and void
        addBoundaryWalls(map) {
            const changes = [];

            for (let z = 0; z < this.maxSize; z++) {
                for (let x = 0; x < this.maxSize; x++) {
                    if (map[z][x] === 0) {
                        // Check 4 cardinal directions for void
                        const dirs = [[0,-1], [0,1], [-1,0], [1,0]];
                        for (const [dz, dx] of dirs) {
                            const nz = z + dz, nx = x + dx;
                            if (map[nz]?.[nx] === -1) {
                                // This floor cell is adjacent to void
                                // Convert the floor to wall and make this cell floor
                                // Actually, we need to add a wall between them
                                // Since we can't add in-between cells, convert floor at boundary to wall
                                changes.push({ z, x });
                                break;
                            }
                        }
                    }
                }
            }

            // Convert boundary floor cells to walls
            for (const c of changes) {
                map[c.z][c.x] = 1;
            }
        }

        generateRooms(map, offset, baseSize, mask, depth) {
            const rooms = [];
            const roomCount = 3 + Math.floor(depth / 2);

            for (let attempt = 0; attempt < roomCount * 50 && rooms.length < roomCount; attempt++) {
                const room = this.tryPlaceRoom(map, offset, baseSize, mask, rooms);
                if (room) rooms.push(room);
            }

            return rooms;
        }

        tryPlaceRoom(map, offset, baseSize, mask, existingRooms) {
            const outerW = 5 + Math.floor(Math.random() * 4);
            const outerH = 5 + Math.floor(Math.random() * 4);

            const rx = offset + 1 + Math.floor(Math.random() * (baseSize - outerW - 2));
            const rz = offset + 1 + Math.floor(Math.random() * (baseSize - outerH - 2));

            // Check if fits (all cells must be floor, not wall or void)
            for (let z = rz; z < rz + outerH; z++) {
                for (let x = rx; x < rx + outerW; x++) {
                    if (map[z]?.[x] !== 0) return null;
                }
            }

            // Check overlap with existing rooms
            for (const room of existingRooms) {
                const r1 = { x: rx + 1, z: rz + 1, w: outerW - 2, h: outerH - 2 };
                const r2 = room.interior;

                if (r1.x < r2.x + r2.w + 2 && r1.x + r1.w + 2 > r2.x &&
                    r1.z < r2.z + r2.h + 2 && r1.z + r1.h + 2 > r2.z) {
                    return null;
                }
            }

            const room = {
                outer: { x: rx, z: rz, w: outerW, h: outerH },
                interior: { x: rx + 1, z: rz + 1, w: outerW - 2, h: outerH - 2 },
                doors: []
            };

            // Place walls around perimeter
            for (let x = rx; x < rx + outerW; x++) {
                map[rz][x] = 1;
                map[rz + outerH - 1][x] = 1;
            }
            for (let z = rz; z < rz + outerH; z++) {
                map[z][rx] = 1;
                map[z][rx + outerW - 1] = 1;
            }

            // Add 1-2 doors
            const doorCount = 1 + Math.floor(Math.random() * 2);
            const edges = ['top', 'bottom', 'left', 'right'].sort(() => Math.random() - 0.5);

            for (let i = 0; i < doorCount && i < edges.length; i++) {
                const door = this.placeDoor(map, room, edges[i]);
                if (door) room.doors.push(door);
            }

            return room;
        }

        placeDoor(map, room, edge) {
            const { outer } = room;
            let x, z;
            let wallCheck1, wallCheck2; // Cells that must be walls (perpendicular to door)

            switch (edge) {
                case 'top':
                    // Door on top wall, need walls on left and right of door
                    x = outer.x + 2 + Math.floor(Math.random() * Math.max(1, outer.w - 4));
                    z = outer.z;
                    wallCheck1 = { x: x - 1, z };
                    wallCheck2 = { x: x + 1, z };
                    break;
                case 'bottom':
                    x = outer.x + 2 + Math.floor(Math.random() * Math.max(1, outer.w - 4));
                    z = outer.z + outer.h - 1;
                    wallCheck1 = { x: x - 1, z };
                    wallCheck2 = { x: x + 1, z };
                    break;
                case 'left':
                    x = outer.x;
                    z = outer.z + 2 + Math.floor(Math.random() * Math.max(1, outer.h - 4));
                    wallCheck1 = { x, z: z - 1 };
                    wallCheck2 = { x, z: z + 1 };
                    break;
                case 'right':
                    x = outer.x + outer.w - 1;
                    z = outer.z + 2 + Math.floor(Math.random() * Math.max(1, outer.h - 4));
                    wallCheck1 = { x, z: z - 1 };
                    wallCheck2 = { x, z: z + 1 };
                    break;
            }

            // Check that walls exist on both sides
            if (map[wallCheck1.z]?.[wallCheck1.x] !== 1 ||
                map[wallCheck2.z]?.[wallCheck2.x] !== 1) {
                return null;
            }

            // Check outside is accessible (floor)
            const outside = this.getOutsideCell(edge, x, z);
            if (map[outside.z]?.[outside.x] !== 0) {
                return null;
            }

            map[z][x] = 2;
            return { x, z, edge };
        }

        getOutsideCell(edge, x, z) {
            switch (edge) {
                case 'top': return { x, z: z - 1 };
                case 'bottom': return { x, z: z + 1 };
                case 'left': return { x: x - 1, z };
                case 'right': return { x: x + 1, z };
            }
        }

        connectRooms(map, rooms) {
            if (rooms.length < 2) return;

            const style = Math.random();

            if (style < 0.5) {
                this.connectWithCorridors(map, rooms);
            }
            // else: open space style
        }

        connectWithCorridors(map, rooms) {
            for (let i = 0; i < rooms.length - 1; i++) {
                const roomA = rooms[i];
                const roomB = rooms[i + 1];

                const doorA = roomA.doors[0];
                const doorB = roomB.doors[0];

                if (!doorA || !doorB) continue;

                this.carveCorridor(map, doorA, doorB);
            }
        }

        carveCorridor(map, doorA, doorB) {
            let { x, z } = this.getOutsideCell(doorA.edge, doorA.x, doorA.z);
            const end = this.getOutsideCell(doorB.edge, doorB.x, doorB.z);

            // Only carve through floor cells (not walls of other rooms)
            const hFirst = Math.random() < 0.5;

            if (hFirst) {
                while (x !== end.x) {
                    x += (end.x > x) ? 1 : -1;
                }
                while (z !== end.z) {
                    z += (end.z > z) ? 1 : -1;
                }
            } else {
                while (z !== end.z) {
                    z += (end.z > z) ? 1 : -1;
                }
                while (x !== end.x) {
                    x += (end.x > x) ? 1 : -1;
                }
            }
        }

        addObstacles(map, rooms) {
            const pillarCount = Math.floor(Math.random() * 3);

            for (let attempt = 0; attempt < pillarCount * 20; attempt++) {
                const x = 2 + Math.floor(Math.random() * (this.maxSize - 4));
                const z = 2 + Math.floor(Math.random() * (this.maxSize - 4));

                if (map[z][x] !== 0) continue;

                let inRoom = false;
                for (const room of rooms) {
                    const { interior } = room;
                    if (x >= interior.x && x < interior.x + interior.w &&
                        z >= interior.z && z < interior.z + interior.h) {
                        inRoom = true;
                        break;
                    }
                }
                if (inRoom) continue;

                // Not near door
                let nearDoor = false;
                for (let dz = -1; dz <= 1 && !nearDoor; dz++) {
                    for (let dx = -1; dx <= 1 && !nearDoor; dx++) {
                        if (map[z + dz]?.[x + dx] === 2) nearDoor = true;
                    }
                }
                if (nearDoor) continue;

                map[z][x] = 1;
            }
        }

        ensureEnclosure(map) {
            // Ensure no floor/door is adjacent to void - add wall if needed
            // Also convert edge floor cells to walls
            let changed = true;
            while (changed) {
                changed = false;
                for (let z = 0; z < this.maxSize; z++) {
                    for (let x = 0; x < this.maxSize; x++) {
                        if (map[z][x] === 0 || map[z][x] === 2) {
                            // Check if this cell is at the edge of the map
                            if (z === 0 || z === this.maxSize - 1 || x === 0 || x === this.maxSize - 1) {
                                map[z][x] = 1; // Edge cells become walls
                                changed = true;
                                continue;
                            }
                            // Check all 8 neighbors for void
                            for (let dz = -1; dz <= 1; dz++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dz === 0 && dx === 0) continue;
                                    const nz = z + dz, nx = x + dx;
                                    if (nz < 0 || nz >= this.maxSize || nx < 0 || nx >= this.maxSize) {
                                        // Out of bounds = treat as void, convert current to wall
                                        map[z][x] = 1;
                                        changed = true;
                                    } else if (map[nz][nx] === -1) {
                                        map[nz][nx] = 1;
                                        changed = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        validateDoors(map) {
            // Check all doors have walls on perpendicular sides
            for (let z = 1; z < this.maxSize - 1; z++) {
                for (let x = 1; x < this.maxSize - 1; x++) {
                    if (map[z][x] === 2) {
                        // Check if valid door configuration
                        const up = map[z-1]?.[x];
                        const down = map[z+1]?.[x];
                        const left = map[z]?.[x-1];
                        const right = map[z]?.[x+1];

                        // Valid: walls on opposite sides, floor/door on other sides
                        const verticalWalls = (left === 1 && right === 1);
                        const horizontalWalls = (up === 1 && down === 1);

                        if (!verticalWalls && !horizontalWalls) {
                            // Invalid door, convert back to wall
                            map[z][x] = 1;
                        }
                    }
                }
            }
        }

        isFullyConnected(map) {
            // Find all walkable cells
            const walkable = [];
            for (let z = 0; z < this.maxSize; z++) {
                for (let x = 0; x < this.maxSize; x++) {
                    if (map[z][x] === 0 || map[z][x] === 2) {
                        walkable.push({ x, z });
                    }
                }
            }
            if (walkable.length === 0) return false;

            // Flood fill from first walkable cell
            const visited = new Set();
            const queue = [walkable[0]];
            visited.add(`${walkable[0].x},${walkable[0].z}`);

            while (queue.length > 0) {
                const { x, z } = queue.shift();
                const dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                for (const [dx, dz] of dirs) {
                    const nx = x + dx, nz = z + dz;
                    const key = `${nx},${nz}`;
                    if (!visited.has(key) && map[nz]?.[nx] !== undefined) {
                        const cell = map[nz][nx];
                        if (cell === 0 || cell === 2) {
                            visited.add(key);
                            queue.push({ x: nx, z: nz });
                        }
                    }
                }
            }

            // Check if all walkable cells were visited
            return visited.size === walkable.length;
        }

        countCells(map, values) {
            let count = 0;
            for (const row of map)
                for (const cell of row)
                    if (values.includes(cell)) count++;
            return count;
        }
    }

    const generator = new DungeonGenerator(36);
    const colors = {
        '-1': '#1a1a2e',
        '0': '#2a2a3a',
        '1': '#5a5a7a',
        '2': '#8B4513'
    };

    function renderMap(result, canvas) {
        const ctx = canvas.getContext('2d');
        const { map, rooms } = result;
        const cellSize = 8;

        canvas.width = generator.maxSize * cellSize;
        canvas.height = generator.maxSize * cellSize;

        for (let z = 0; z < generator.maxSize; z++) {
            for (let x = 0; x < generator.maxSize; x++) {
                ctx.fillStyle = colors[map[z][x]] || '#ff0000';
                ctx.fillRect(x * cellSize, z * cellSize, cellSize, cellSize);
            }
        }

        ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
        ctx.lineWidth = 1;
        for (const room of rooms) {
            const { interior } = room;
            ctx.strokeRect(
                interior.x * cellSize,
                interior.z * cellSize,
                interior.w * cellSize,
                interior.h * cellSize
            );
        }
    }

    function generateAll() {
        const grid = document.getElementById('grid');
        grid.innerHTML = '';

        for (let i = 0; i < 16; i++) {
            const depth = (i % 8) + 1;
            const result = generator.generate(depth);

            const container = document.createElement('div');
            container.className = 'map-container';

            const header = document.createElement('div');
            header.className = 'map-header';
            header.innerHTML = `
                <span class="shape">${result.shape.toUpperCase()}</span>
                <span class="stats">D${depth} | ${result.rooms.length}ÂÆ§ ${result.doors}ÈñÄ</span>
            `;

            const canvas = document.createElement('canvas');
            renderMap(result, canvas);

            container.appendChild(header);
            container.appendChild(canvas);
            grid.appendChild(container);
        }
    }

    function generateByShape(shape) {
        const grid = document.getElementById('grid');
        grid.innerHTML = '';

        for (let i = 0; i < 16; i++) {
            const depth = (i % 8) + 1;
            const result = generator.generate(depth, shape);

            const container = document.createElement('div');
            container.className = 'map-container';

            const header = document.createElement('div');
            header.className = 'map-header';
            header.innerHTML = `
                <span class="shape">${result.shape.toUpperCase()}</span>
                <span class="stats">D${depth} | ${result.rooms.length}ÂÆ§ ${result.doors}ÈñÄ</span>
            `;

            const canvas = document.createElement('canvas');
            renderMap(result, canvas);

            container.appendChild(header);
            container.appendChild(canvas);
            grid.appendChild(container);
        }
    }

    generateAll();
    </script>
</body>
</html>
